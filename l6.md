# Самостоятельная работа: «Анатомия системного сбоя» с помощью `strace`

## Цель

Прокачать практический навык поиска причин сбоев и «тормозов» в Linux-процессах с помощью `strace`:

* чтение системных вызовов (openat, connect, read/write, futex, poll/epoll, stat, access, getaddrinfo и т.д.);
* диагностика I/O-ошибок, прав, отсутствующих файлов/каталогов, блокировок, сетевых таймаутов и зависаний;
* фиксация времени/латентности вызовов, трассировка детей/тредов, фильтрация по типам вызовов;
* привязка симптомов к корневой причине и формулировка фикса.

---

## Правила сдачи

Репозиторий с такой структурой (пример):

```
strace-lab/
├── README.md
├── tasks/
│   ├── 01-permissions/
│   │   ├── broken.sh
│   │   ├── expected.txt
│   │   └── analysis.md
│   ├── 02-missing-file/
│   ├── 03-dns-timeout/
│   ├── 04-port-denied/
│   ├── 05-file-lock/
│   ├── 06-slow-fsync/
│   ├── 07-daemonize/
│   └── 08-seccomp-apparmor/
├── scripts/                 # утилиты для проверки/подготовки
├── logs/                    # .strace логи (текст)
└── Makefile                 # быстрые цели запуска/проверки
```

**Никаких скриншотов.**
Сдаёте:

* исходники «сломанных» утилит/скриптов (где требуется — задал заготовки ниже);
* команды `strace` (с флагами) и **сырые логи** (`logs/*.strace`);
* краткий **разбор** в `analysis.md` на каждую подзадачу: «симптом → наблюдение → syscall-улика → причина → фикc/обход».

---

## Инструментальная «шпаргалка strace» (разрешено пользоваться)

* Общие флаги:

  * `-f` — следить за потомками (fork/clone/vfork, треды).
  * `-o file` / `-ff -o file` — лог в файл (по PID, если `-ff`).
  * `-tt`/`-ttt`/`-tttt` — время; `-T` — длительность каждого syscall.
  * `-y`/`-yy` — показывать пути к дескрипторам/сокетам (полезно для сети).
  * `-s 200` — длина строк/буферов; `-v` — разворачивать структуры.
  * `-e trace=…` — фильтр: `file`, `network`, `process`, `memory`, или явный список: `openat,stat,connect,…`.
  * `-p <pid>` — приаттачиться к уже работающему процессу (detach: `^C` или `-w` дождаться).
  * `-k` — backtrace (если есть отладочные символы).
* Частые паттерны:

  * **файлы/права**: `strace -ff -o logs/t1 -tt -T -y -e trace=file ./broken.sh`
  * **сеть/DNS**: `strace -ff -o logs/t3 -tt -T -yy -e trace=network,recvfrom,sendto,connect,select,poll,epoll_pwait ./client.sh`
  * **«почему висит?»**: `strace -p <pid> -tt -T -f -s 200 -y -yy` и смотрим последний вызов (futex, ppoll, read, connect, …)

---

## Набор задач

> Все примеры под Debian 12 (bash, coreutils есть «из коробки»). Где нужен Python — используйте `/usr/bin/python3`. Где нужен компилятор — либо `gcc`, либо перепишите на shell/Python.

### 01. «Недостаточно прав» (permissions)

**broken.sh** (пример заготовки):

```bash
#!/usr/bin/env bash
# Пытается писать в файл, каталог которого создан с «плохими» правами
set -euo pipefail
mkdir -p /tmp/secret-dir
chmod 0555 /tmp/secret-dir
exec 3> /tmp/secret-dir/data.txt
echo "hello" >&3
```

**Симптом:** «не создаётся файл».
**Что сделать:**

* Запустить с `strace -e trace=file -tt -T -y -o logs/01.strace ./broken.sh`;
* Найти **конкретный** syscall и код ошибки (`EACCES`/`EPERM`), показать, к чему обращался процесс (путь/дескриптор);
* Исправить (обосновать безопасные права: на каталог нужен `+w` и `+x` для создания/входа);
* В `analysis.md` — укажите «какой вызов упал, почему, как починили».

### 02. «Нет такого файла/каталога» (missing file)

**broken.sh**:

```bash
#!/usr/bin/env bash
set -euo pipefail
cat /opt/app/config/settings.yaml
```

**Симптом:** «не находит конфиг».
Задача: `strace -e trace=file -s 120 -tt -T -o logs/02.strace ./broken.sh` → найти **какие пути** реально проверяются (последовательные `stat/openat`), где именно случается `ENOENT`. Предложить варианты фикса (создать, поправить путь, сделать bind-mount, env var).

### 03. «Долго открывается сайт» (DNS timeout / сеть)

**client.py**:

```python
#!/usr/bin/env python3
import urllib.request; print(urllib.request.urlopen("http://example.local:8080/", timeout=3).read().decode())
```

**Симптом:** «висит ~5–6 секунд, потом ошибка».
Спрячьте `example.local` в свой /etc/hosts/DNS так, чтобы **A-запись отсутствовала** (или резолв указывает на неотвечающий IP/порт).
Сделайте `strace`:

```
strace -f -tt -T -yy -s 200 -o logs/03.strace -e trace=network,recvfrom,sendto,connect,getsockopt,getaddrinfo,select,poll,epoll_pwait python3 client.py
```

Найдите:

* `getaddrinfo` (DNS-резолв), попытки v6/v4, таймауты/повторения;
* `connect(...) = -1 ETIMEDOUT`/`ECONNREFUSED` и длительность (`-T`);
* Покажите, **где именно пропало время**: DNS или TCP connect.
  Опишите правку (правильная A-запись, открытый порт, работающий backend).

### 04. «Порт закрыт / firewall» (connection refused)

Простой TCP-клиент (bash):

```bash
#!/usr/bin/env bash
# tries to connect to 127.0.0.1:9999
exec 3<>/dev/tcp/127.0.0.1/9999 || exit 1
echo "ping" >&3; cat <&3
```

`strace -tt -T -yy -e trace=network -o logs/04.strace ./tcp.sh`
Покажите `connect(...) = -1 ECONNREFUSED`, разницу с таймаутом из задачи 03, и как меняется картина после `nc -l -p 9999` (успешный `connect`, `sendto`/`recvfrom`).

### 05. «Висим на блокировке» (file lock / futex)

**lock.py**:

```python
#!/usr/bin/env python3
import fcntl, time, sys
fd = open("/tmp/shared.lock", "w")
fcntl.flock(fd, fcntl.LOCK_EX)     # эксклюзивная блокировка
print("locked", flush=True)
time.sleep(300)
```

1. Запустите **две копии** в разных терминалах.
2. На второй повесьте `strace -p <pid> -tt -T -f -s 200 -y -o logs/05.strace`.
   Найдите, где именно процесс ждёт: вызовы `fcntl(F_SETLKW, ...)` → блок (и/или `futex` если библиотека).
   Покажите, как освободить: снять лок в первом процессе, мгновенный прогресс второго.

### 06. «Почему запись долгая?» (медленный fsync)

**slow_write.py**:

```python
#!/usr/bin/env python3
import os, time
with open("/tmp/bigfile", "wb", buffering=0) as f:
    f.write(b"x"*1024*1024*64)
    os.fsync(f.fileno())
```

`strace -tt -T -e trace=write,fsync,futex -o logs/06.strace python3 slow_write.py`
Покажите длительность на `fsync` (часто львиная доля времени), обоснуйте, почему так (ждём записи на носитель), предложите варианты (batched writes, `sync=0` если можно, tmpfs для временных файлов, `O_DIRECT`/журналирование — по ситуации).

### 07. «Демон не стартует/висит при старте» (daemonize / children)

Дайте сервис, который форкается и теряет stdout/stderr/рабочий каталог:

```bash
#!/usr/bin/env bash
# daemon.sh
( cd /nonexistent && exec sleep 1000 ) &
```

`systemd`-юнит (или просто запуск):

* Аттач `strace -ff -o logs/07 -tt -T -f -s 120 -y -p <pid_of_parent>` и проследите за потомком.
* Найдите `chdir("/nonexistent") = -1 ENOENT`, объясните, почему внешне «тихо упало», как поймать именно дочерний поток (`-f`, `-ff`).

### 08. «Запрещено политикой» (seccomp / AppArmor) — **повышенная сложность**

Организуйте минимальный кейс (любой из двух):

* **seccomp**: запустите утилиту в неймспейсе через `unshare`/`bubblewrap` с профилем, запрещающим `clone3`/`socket` → в `strace` будет `EPERM`/`ENOSYS`.
* **AppArmor**: включите профиль, запрещающий доступ к `/etc/shadow`, продемонстрируйте `EACCES`/`EPERM` на соответствующем `openat`.

Разбор: чем отличается отказ «правами» (EACCES/EPERM), «отсутствием» (ENOENT) и «не тем syscall’ом» (ENOSYS). Как это читается в логах.

---

## README.md — что обязательно описать

* Как воспроизвести каждую задачу (команда запуска, что именно «сломано»).
* Конкретные команды `strace` (с флагами) и зачем выбран каждый из них.
* Где искать улики в логах: какой **syscall**, какой **errno**, какой **аргумент** (путь/адрес/порт/флаги).
* Итог: формулировка **корневой причины** и **исправления**.

---

## Makefile (пример)

```make
all: test

prep:
\tchmod +x tasks/*/*.sh tasks/*/*.py

t01:
\tstrace -tt -T -y -e trace=file -o logs/01.strace ./tasks/01-permissions/broken.sh || true

t02:
\tstrace -tt -T -s 200 -e trace=file -o logs/02.strace ./tasks/02-missing-file/broken.sh || true

# … аналогично t03..t08

test: prep t01 t02
\t@echo "collect logs/ and write analyses in tasks/*/analysis.md"
```

---

## Критерии оценки

* **Полнота логов** (есть все `.strace`, читаемые, с нужными флагами) — 15%
* **Точность диагностики** (правильный syscall+errno, чёткая связь с симптомом) — 20%
* **Разумный фикс/обход** (без костылей уровня «sudo 777») — 20%
* **Оформление** (README, структура, воспроизводимость) — 10%
* **Глубина анализа времени** (`-T`, где «съедается» латентность) — 10%
* Сравнение разных уровней детализации (`-tt` vs `-ttt` vs `-T`, `-y` vs `-yy`); 5%
* Демонстрация различий `ECONNREFUSED` vs `ETIMEDOUT` на сети; 10%
* Пример с `-p` на живой сервис: «почему завис nginx/чей-то скрипт» (поймать на `futex`/`recvfrom`/`ppoll`); 5%
* Использование `-e status=failed` (strace умеет фильтровать по неуспешным вызовам). 5%

---

## Подводные камни

* `strace` **тормозит** процесс; на проде — осторожно, на малых окнах времени.
* Для сети без `-yy` вы не увидите, **к какому адресу/порту** шёл `connect`.
* `-f` обязателен для демонов/форков; иначе «пропустите» ошибку ребёнка.
* «Права» на каталог и «права» на файл — разные: для создания файла нужны `+w` и **`+x` на каталог**.
* `ENOENT` ≠ «файл не существует» всегда — путь может рваться на любом сегменте.
* DNS и TCP таймауты — разные симптомы (смотрите, где уходит время).


