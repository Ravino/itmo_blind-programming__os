# Самостоятельная работа: Nginx-прокси во внутренней сети с двумя бэкендами

## Цель

Научиться:

* поднимать Nginx как reverse-proxy во «серой» сети;
* балансировать трафик на два HTTP-бэкенда, размещённые на разных хостах;
* организовывать понятную диагностику (логи, health-checks, текстовые пробы);
* оформлять результат reproducible: конфиги, юниты, скрипты — всё в репозитории.

## Условия и топология

* Минимум **3 хоста** во внутренней L2/L3-сети из прошлой работы (или эквивалентной «серой» сети):

  * `proxy01` — Nginx (reverse proxy).
  * `app01` — бэкенд №1.
  * `app02` — бэкенд №2.
* Внутренний DNS из прошлой работы (зона `dc.local`) или статические `/etc/hosts`.
* Порты:

  * Nginx слушает **:80** (опционально :443).
  * Бэкенды слушают **:8080** (можно другое, но одинаково на обоих).

## Функциональные требования

1. **Бэкенды** отвечают по HTTP и возвращают простой текст вида:

   ```
   backend=app01  host=app01.dc.local  pod=1  time=2025-09-25T12:34:56Z
   ```

   (Должно быть очевидно, на какой бэкенд пришёл запрос.)
2. **Nginx**:

   * upstream с **двумя** серверами (`app01:8080`, `app02:8080`);
   * балансировка: по умолчанию round-robin (допускается `least_conn`);
   * проксирует `GET /` на upstream, **пробрасывает** заголовки `X-Forwarded-For`, `X-Forwarded-Proto`, `X-Request-Id`;
   * health-checks (простые): `proxy_next_upstream` для ошибок/таймаутов, `max_fails`/`fail_timeout` в `upstream`; опционально — отдельный `/healthz` на бэкендах;
   * **логи в JSON** (access) с полями: ts, req_id, client_ip, upstream, status, rt, urt.
3. **Сетевая безопасность**:

   * бэкенды принимают соединения **только** от `proxy01` (файрвол/iptables или `listen 127.0.0.1` + ssh-tunnel — но лучше firewall).
   * снаружи «серой» сети доступен **только** `proxy01:80`.
4. **DNS**:

   * имена `proxy01.dc.local`, `app01.dc.local`, `app02.dc.local` резолвятся в ваши внутренние IP.

## Технические подсказки

### Мини-бэкенд (вариант A: Python)

Файл `app.py`:

```python
from http.server import BaseHTTPRequestHandler, HTTPServer
import os, socket, datetime
NAME = os.environ.get("APP_NAME", socket.gethostname())

class H(BaseHTTPRequestHandler):
    def do_GET(self):
        body = f"backend={NAME} host={socket.gethostname()} time={datetime.datetime.utcnow().isoformat()}Z\n"
        self.send_response(200); self.send_header("Content-Type","text/plain"); self.end_headers()
        self.wfile.write(body.encode())
    def log_message(self, fmt, *args): return

HTTPServer(("0.0.0.0", int(os.environ.get("PORT","8080"))), H).serve_forever()
```

Юнит `systemd` (`/etc/systemd/system/simple-backend.service`):

```ini
[Unit]
Description=Simple HTTP backend
After=network-online.target
Wants=network-online.target

[Service]
Environment=APP_NAME=%i PORT=8080
ExecStart=/usr/bin/python3 /opt/simple-backend/app.py
Restart=always
User=www-data
Group=www-data

[Install]
WantedBy=multi-user.target
```

Установить код на `app01`/`app02` в `/opt/simple-backend/`, включить как `simple-backend@app01` и `simple-backend@app02`.

### Мини-бэкенд (вариант B: BusyBox)

```bash
# /opt/simple-backend/run.sh
#!/usr/bin/env bash
APP_NAME=${APP_NAME:-$(hostname)}
PORT=${PORT:-8080}
while true; do
  { printf 'HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n\r\nbackend=%s host=%s time=%sZ\n' \
      "$APP_NAME" "$(hostname)" "$(date -u +%FT%T)"; } | nc -l -p "$PORT" -q 1
done
```

(менее надёжно, но без Python/Node).

### Пример `nginx` конфигурации (файл в репозитории)

`/etc/nginx/conf.d/app.conf`:

```nginx
upstream app_backend {
    server app01.dc.local:8080 max_fails=2 fail_timeout=5s;
    server app02.dc.local:8080 max_fails=2 fail_timeout=5s;
    keepalive 32;
}

map $http_x_request_id $reqid { default $http_x_request_id; "" $request_id; }

log_format json_logs escape=json
  '{ "ts":"$time_iso8601", "remote":"$remote_addr", "req":"$request",
     "status":$status, "bytes":$body_bytes_sent,
     "rt":$request_time, "urt":$upstream_response_time,
     "upstream":"$upstream_addr", "req_id":"$reqid", "ua":"$http_user_agent" }';

server {
    listen 80 default_server;
    server_name proxy01.dc.local _;

    access_log /var/log/nginx/access.json json_logs;
    error_log  /var/log/nginx/error.log warn;

    location /healthz { return 200; }

    location / {
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Request-Id      $reqid;

        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_read_timeout 5s;
        proxy_send_timeout 5s;

        proxy_next_upstream error timeout http_502 http_503 http_504;
        proxy_pass http://app_backend;
    }
}
```

### Файрвол

* На `app01`/`app02` открыть `8080/tcp` **только** для IP `proxy01`.
* Закрыть всё прочее входящее.

## Проверки (все результаты — **текстом**)

Добавьте в репозиторий файлы `checks/…` с результатами:

1. **DNS**
   `checks/dns.txt` — вывод:

   ```bash
   host app01.dc.local
   host app02.dc.local
   host proxy01.dc.local
   ```
2. **Доступность бэкендов с proxy01**
   `checks/backend.txt`:

   ```
   curl -s http://app01.dc.local:8080/
   curl -s http://app02.dc.local:8080/
   ```
3. **Балансировка**
   `checks/proxy-roundrobin.txt` — 10 запросов:

   ```
   for i in {1..10}; do curl -s http://proxy01.dc.local/; done
   ```

   Ожидаем чередование ответов (или по крайней мере присутствие обоих бэкендов).
4. **Логи Nginx**
   `checks/access-sample.json` — 10 строк из `/var/log/nginx/access.json`:
   каждая строка валидный JSON, поле `upstream` указывает адрес обслужившего бэкенда.
5. **Failover (имитация сбоя)**

   * Остановите `app02` на время (`systemctl stop simple-backend@app02`).
   * `checks/failover.txt` — 5 запросов к `proxy01` и соответствующие строки из лога Nginx:
     убедитесь, что запросы идут только на `app01`, ошибок 502/504 нет.
   * Верните `app02` и покажите восстановление балансировки.

## Репозиторий: структура

```
.
├── README.md
├── dns/
│   ├── zone.dc.local      # если bind9 — файл зоны (или dnsmasq.conf фрагмент)
│   └── named.conf.local   # опционально
├── proxy/
│   └── nginx.conf.d/app.conf
├── app/
│   ├── app.py             # или run.sh (вариант B)
│   └── systemd/simple-backend@.service
├── firewall/
│   ├── app01.rules
│   └── app02.rules
└── checks/
    ├── dns.txt
    ├── backend.txt
    ├── proxy-roundrobin.txt
    ├── access-sample.json
    └── failover.txt
```

## README.md — что обязательно описать

* **Топология**: хосты, их внутренние IP/имена.
* **Как развернуть**:

  1. установка зависимостей (nginx, python3 или busybox/netcat, bind9|dnsmasq);
  2. куда класть файлы, какие команды `systemctl enable --now …`;
  3. как применить правила firewall.
* **Как проверить** (команды, которые вы уже положили в `checks/`).
* **Как воспроизвести failover-тест**.

## Критерии оценки

* **40%** — два бэкенда на разных хостах, корректно отвечают, различимы по содержимому ответа.
* **40%** — Nginx корректно проксирует и балансирует, настроены заголовки, есть health-handling, логи в JSON.
* **10%** — DNS корректно работает во внутренней сети.
* **10%** — сетевые ограничения: бэкенды не доступны напрямую извне (только с proxy).
